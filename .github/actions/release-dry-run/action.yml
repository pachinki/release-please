name: "Release Dry Run"
description: "Compute the next semantic version using release-please in dry-run mode and emit parsed outputs."
author: "cai-platform"
branding:
  icon: "tag"
  color: "blue"

inputs:
  target-branch:
    description: "Target (default) branch to compare against"
    required: false
    default: "main"
  release-type:
    description: "release-please release type (simple|manifest|node|python|...)"
    required: false
    default: "simple"
  package-name:
    description: "Package / manifest key name passed to release-please"
    required: false
    default: "workflows"
  path:
    description: "Subdirectory root scanned for commits"
    required: false
    default: "."
  artifact-name:
    description: "Base name for uploaded log artifact (will hold dry run log)"
    required: false
    default: "release-please-dry-run-log"
  unique-suffix:
    description: "If 'true', append path + job + run_attempt to artifact name to avoid 409 conflicts when action runs multiple times in a workflow"
    required: false
    default: "true"
  pr-comment:
    description: "If 'true', post (or update) a PR comment with predicted version details when running on pull_request events"
    required: false
    default: "true"
  pr-comment-marker:
    description: "Hidden HTML marker used to find & update the prior comment instead of creating duplicates"
    required: false
    default: "release-please-dry-run-marker"
  show-raw-exit-code:
    description: "If 'true', include Raw Exit Code row in PR comment table"
    required: false
    default: "false"
  enforce-major-approval:
    description: "If 'true', add labels and require approval for major version bumps"
    required: false
    default: "true"

outputs:
  current_tag:
    description: "Current latest tag (vX.Y.Z)"
    value: ${{ steps.baseline.outputs.current_tag }}
  next_tag:
    description: "Next tag after merge (vX.Y.Z)"
    value: ${{ steps.forward_predict.outputs.next_tag }}
  bump_type:
    description: "Semantic bump type (none|patch|minor|major)"
    value: ${{ steps.forward_predict.outputs.bump_type }}
  major_bump_detected:
    description: "True if major bump was detected and protection was applied"
    value: ${{ github.event_name == 'pull_request' && steps.forward_predict.outputs.bump_type == 'major' && inputs['enforce-major-approval'] == 'true' }}

runs:
  using: "composite"
  steps:
    - name: Setup Node
      uses: actions/setup-node@v4
      with:
        node-version: "20"

    - name: Install release-please CLI
      shell: bash
      run: npm install -g release-please

    - name: Ensure full git history (best-effort)
      shell: bash
      run: |
        set -euo pipefail
        # Attempt to unshallow so describe/commit scan works; ignore if already full.
        git fetch --prune --tags --unshallow 2>/dev/null || true
        # Fallback shallow fetch of tags if unshallow not possible
        git fetch --prune --tags --depth=200 2>/dev/null || true
        # Make sure we have the latest default branch ref (important for PR context)
        git fetch origin "${{ inputs['target-branch'] }}" --depth=200 2>/dev/null || true

    - name: Validate PR Title (Prevent Release Issues)
      if: ${{ github.event_name == 'pull_request' }}
      shell: bash
      run: |
        set -euo pipefail
        PR_TITLE="${{ github.event.pull_request.title }}"
        HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
        echo "ðŸ” Checking PR title: $PR_TITLE"
        echo "ðŸ” Source branch: $HEAD_BRANCH"

        # Check if PR title follows conventional commit format (strict) or GitHub auto-generated format (flexible)
        if ! echo "$PR_TITLE" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?[:/] .+' && \
           ! echo "$PR_TITLE" | grep -qE '^(Feat|Fix|Docs|Style|Refactor|Perf|Test|Build|Ci|Chore|Revert)[/] .+' && \
           ! echo "$PR_TITLE" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)[/-] .+'; then
          echo "âŒ ERROR: PR title must follow conventional commit format!"
          echo ""
          echo "Examples:"
          echo "  âœ… feat: add new functionality"
          echo "  âœ… fix: resolve login issue" 
          echo "  âœ… chore: update dependencies"
          echo "  âœ… Feat/user export (GitHub auto-generated - capitalized)"
          echo "  âœ… feat/pre-release (GitHub auto-generated - lowercase)"
          echo "  âœ… feat-pre-release (GitHub auto-generated - with hyphen)"
          echo ""
          echo "Current title: '$PR_TITLE'"
          echo ""
          echo "ðŸ’¡ TIP: Use conventional branch names to get better auto-generated PR titles:"
          echo "  Branch 'feat/user-export' â†’ PR title 'Feat/user export'"
          echo "  Branch 'fix/login-bug' â†’ PR title 'Fix/login bug'"
          echo ""
          echo "âš ï¸  This title becomes the merge commit message and must be conventional for releases to work!"
          echo "ðŸ”§ Fix: Edit your PR title to use format 'type: description'"
          exit 1
        fi
        echo "âœ… PR title follows conventional commit format"

    - name: Get current tag baseline
      id: baseline
      shell: bash
      run: |
        set -euo pipefail
        DEFAULT_BRANCH='${{ inputs['target-branch'] }}'
        git fetch origin "$DEFAULT_BRANCH" --tags --force >/dev/null 2>&1 || true
        # Find highest semver tag on default branch
        CANDIDATES=$(git tag --merged "origin/$DEFAULT_BRANCH" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)
        if [ -n "$CANDIDATES" ]; then
          CURRENT_TAG=$(echo "$CANDIDATES" | awk -F'[v.]' '{printf "%s %d %d %d\n",$0,$2,$3,$4}' | sort -k2,2n -k3,3n -k4,4n | tail -n1 | cut -d' ' -f1)
        else
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo 'v0.0.0')
        fi
        echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
        echo "Current tag: $CURRENT_TAG" | tee -a baseline.log

    - name: Predict next tag after merge
      id: forward_predict
      if: github.event_name == 'pull_request'
      shell: bash
      run: |
        set -euo pipefail
        TARGET='${{ inputs['target-branch'] }}'
        CURRENT_TAG='${{ steps.baseline.outputs.current_tag }}'
        CURRENT_VER=${CURRENT_TAG#v}

        # Normalize to three-part semver
        if [[ ! "$CURRENT_VER" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
          IFS=. read -r LV_M LV_m LV_p <<< "$CURRENT_VER"
          LV_M=${LV_M:-0}; LV_m=${LV_m:-0}; LV_p=${LV_p:-0}
          CURRENT_VER="$LV_M.$LV_m.$LV_p"
        fi
        IFS=. read -r MAJ MIN PAT <<< "$CURRENT_VER"

        # Check PR-only commits for bump type
        PR_COMMITS=$(git log --pretty=format:'%s%n%b' origin/$TARGET..HEAD || true)
        if [ -z "$PR_COMMITS" ]; then
          BUMP=none
        elif echo "$PR_COMMITS" | grep -Eiq 'BREAKING CHANGE|!:'; then
          BUMP=major
        elif echo "$PR_COMMITS" | grep -Eiq '^[[:space:]]*feat(\(|:)' ; then
          BUMP=minor
        elif echo "$PR_COMMITS" | grep -Eiq '^[[:space:]]*(fix|perf)(\(|:)|bugfix|hotfix' ; then
          BUMP=patch
        else
          # All other commit types result in no version bump
          BUMP=none
        fi

        # Calculate next version
        case $BUMP in
          major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
          minor) MIN=$((MIN+1)); PAT=0 ;;
          patch) PAT=$((PAT+1)) ;;
          none) : ;;
        esac

        NEXT_VER="$MAJ.$MIN.$PAT"
        NEXT_TAG="v$NEXT_VER"

        echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
        echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
        echo "Next tag after merge: $NEXT_TAG (bump: $BUMP)" | tee -a baseline.log

    - name: Check for Version Conflicts
      if: github.event_name == 'pull_request'
      id: conflict_check
      shell: bash
      run: |
        set -euo pipefail
        NEXT_TAG='${{ steps.forward_predict.outputs.next_tag }}'
        TARGET_BRANCH='${{ inputs['target-branch'] }}'

        # Check if the next tag already exists
        if git tag | grep -q "^${NEXT_TAG}$"; then
          echo "version_conflict=true" >> $GITHUB_OUTPUT
          echo "conflict_message=âš ï¸ Version conflict detected: Tag $NEXT_TAG already exists!" >> $GITHUB_OUTPUT
          echo "VERSION CONFLICT: $NEXT_TAG already exists" | tee -a baseline.log
        else
          echo "version_conflict=false" >> $GITHUB_OUTPUT
          echo "conflict_message=" >> $GITHUB_OUTPUT
          echo "No version conflicts detected" | tee -a baseline.log
        fi

    - name: Compute artifact name
      id: artifact_name
      shell: bash
      run: |
        set -euo pipefail
        BASE="${{ inputs['artifact-name'] }}"
        if [ "${{ inputs['unique-suffix'] }}" = "true" ]; then
          P="${{ inputs.path }}"
          [ "$P" = "." ] && P="root"
          SAFE=$(echo "$P" | tr '/ ' '__')
          VALUE="${BASE}-${SAFE}-${{ github.job }}-${{ github.run_attempt }}"
        else
          VALUE="$BASE"
        fi
        echo "Computed artifact name: $VALUE"
        echo "value=$VALUE" >> $GITHUB_OUTPUT

    - name: Upload log
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.artifact_name.outputs.value }}
        path: baseline.log
        if-no-files-found: warn

    - name: Major Bump Protection
      if: ${{ github.event_name == 'pull_request' && steps.forward_predict.outputs.bump_type == 'major' && inputs['enforce-major-approval'] == 'true' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const {owner, repo} = context.repo;
          const issue_number = context.issue.number;

          // Add major-release and requires-approval labels
          try {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number,
              labels: ['major-release', 'requires-approval']
            });
            core.info('Added major-release and requires-approval labels');
          } catch (error) {
            core.warning(`Failed to add labels: ${error.message}`);
          }

          // Post warning comment about major bump
          const warningMarker = '<!-- major-bump-warning -->';
          const currentTag = `${{ steps.baseline.outputs.current_tag }}`;
          const nextTag = `${{ steps.forward_predict.outputs.next_tag }}`;

          const warningBody = warningMarker + `
          ## âš ï¸ Major Version Bump Detected!

          This PR contains **breaking changes** that will create a major release:

          - **Current Version**: \`${currentTag}\`
          - **Next Version**: \`${nextTag}\`
          - **Impact**: This is a **BREAKING CHANGE** that may affect consumers

          ### Required Actions:
          1. ðŸ·ï¸ **Labels Added**: \`major-release\`, \`requires-approval\`
          2. ðŸ‘¥ **Review Required**: A senior maintainer must approve this PR
          3. ðŸ“‹ **Breaking Changes**: Document all breaking changes in the PR description
          4. ðŸ“¢ **Communication**: Plan release announcement and migration guide

          ### Before Merging:
          - [ ] Breaking changes documented
          - [ ] Migration guide provided
          - [ ] Team/consumers notified
          - [ ] Senior maintainer approval obtained

          **Do not merge until all requirements are met!**`;

          // Check if warning comment already exists
          const comments = await github.paginate(github.rest.issues.listComments, {owner, repo, issue_number});
          const existingWarning = comments.find(c => c.body && c.body.includes(warningMarker));

          if (existingWarning) {
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: existingWarning.id,
              body: warningBody
            });
            core.info('Updated existing major bump warning comment');
          } else {
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: warningBody
            });
            core.info('Created new major bump warning comment');
          }

          // Request reviews from repository maintainers (if CODEOWNERS exists)
          try {
            const codeowners = await github.rest.repos.getContent({
              owner,
              repo,
              path: '.github/CODEOWNERS'
            });
            core.info('CODEOWNERS file found - review requests should be automatic');
          } catch (error) {
            core.warning('No CODEOWNERS file found. Consider adding one for automatic review requests on major bumps.');
          }

    - name: PR Comment (Simple Version)
      if: ${{ github.event_name == 'pull_request' && inputs['pr-comment'] == 'true' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const marker = '<!-- ' + `${{ inputs['pr-comment-marker'] }}` + ' -->';
          const currentTag = `${{ steps.baseline.outputs.current_tag }}` || 'none';
          const nextTag = `${{ steps.forward_predict.outputs.next_tag }}` || 'none';
          const bumpType = `${{ steps.forward_predict.outputs.bump_type }}` || 'none';
          const hasVersionConflict = `${{ steps.conflict_check.outputs.version_conflict }}` === 'true';
          const conflictMessage = `${{ steps.conflict_check.outputs.conflict_message }}`;

          // Add warning icon for major bumps or version conflicts
          const bumpTypeDisplay = bumpType === 'major' ? 'âš ï¸ `major` (BREAKING)' : `\`${bumpType}\``;
          const headerEmoji = bumpType === 'major' || hasVersionConflict ? 'âš ï¸ ' : '';

          // Build version conflict warning
          const versionConflictWarning = hasVersionConflict ? `

          > **ðŸš¨ VERSION CONFLICT DETECTED!**
          > 
          > ${conflictMessage}
          > 
          > **Resolution needed:**
          > 1. Rebase your branch: \`git rebase v${ nextTag.replace('v', '').split('.').slice(0, 2).join('.') }.0\`
          > 2. Update any RC tags if needed
          > 3. The version will automatically increment to the next available number
          ` : '';

          const body = marker + `
          ### ${headerEmoji}Release Dry Run Result

          | Field | Value |
          |-------|-------|
          | Current Tag | \`${currentTag}\` |
          | Next Tag After Merge | \`${nextTag}\` |
          | Bump Type | ${bumpTypeDisplay} |

          ${bumpType === 'major' ? '> **Warning**: This PR contains breaking changes! Check labels and approval requirements.' : ''}${versionConflictWarning}

          _Comment updates automatically on each run._`;

          const {owner, repo} = context.repo;
          const issue_number = context.issue.number;
          // Fetch existing comments and look for marker
          const comments = await github.paginate(github.rest.issues.listComments, {owner, repo, issue_number});
          const existing = comments.find(c => c.body && c.body.includes(marker));
          if (existing) {
            await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            core.info('Updated existing dry-run comment.');
          } else {
            await github.rest.issues.createComment({owner, repo, issue_number, body});
            core.info('Created new dry-run comment.');
          }

    - name: Step Summary
      if: always()
      shell: bash
      run: |
        {
          echo '### Release Dry Run';
          echo '';
          echo '* Current tag: `${{ steps.baseline.outputs.current_tag }}`';
          echo '* Next tag: `${{ steps.forward_predict.outputs.next_tag }}`';
          echo '* Bump type: `${{ steps.forward_predict.outputs.bump_type }}`';
        } >> $GITHUB_STEP_SUMMARY
