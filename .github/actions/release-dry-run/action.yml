name: "Release Dry Run"
description: "Compute the next semantic version using release-please in dry-run mode and emit parsed outputs."
author: "cai-platform"
branding:
  icon: "tag"
  color: "blue"

inputs:
  target-branch:
    description: "Target (default) branch to compare against"
    required: false
    default: "main"
  release-type:
    description: "release-please release type (simple|manifest|node|python|...)"
    required: false
    default: "simple"
  config-file:
    description: "Path to release-please config file"
    required: false
    default: "release-please-config.json"
  manifest-file:
    description: "Path to release-please manifest file"
    required: false
    default: ".release-please-manifest.json"
  package-name:
    description: "Package / manifest key name passed to release-please"
    required: false
    default: "workflows"
  path:
    description: "Subdirectory root scanned for commits"
    required: false
    default: "."
  artifact-name:
    description: "Base name for uploaded log artifact (will hold dry run log)"
    required: false
    default: "release-please-dry-run-log"
  unique-suffix:
    description: "If 'true', append path + job + run_attempt to artifact name to avoid 409 conflicts when action runs multiple times in a workflow"
    required: false
    default: "true"
  pr-comment:
    description: "If 'true', post (or update) a PR comment with predicted version details when running on pull_request events"
    required: false
    default: "true"
  pr-comment-marker:
    description: "Hidden HTML marker used to find & update the prior comment instead of creating duplicates"
    required: false
    default: "release-please-dry-run-marker"
  show-raw-exit-code:
    description: "If 'true', include Raw Exit Code row in PR comment table"
    required: false
    default: "false"
  enforce-major-approval:
    description: "If 'true', add labels and require approval for major version bumps"
    required: false
    default: "true"

outputs:
  current_tag:
    description: "Current latest tag (vX.Y.Z)"
    value: ${{ steps.baseline.outputs.current_tag }}
  next_tag:
    description: "Next tag after merge (vX.Y.Z)"
    value: ${{ github.event_name == 'pull_request' && steps.forward_predict.outputs.next_tag || steps.current_predict.outputs.next_tag }}
  bump_type:
    description: "Semantic bump type (none|patch|minor|major)"
    value: ${{ github.event_name == 'pull_request' && steps.forward_predict.outputs.bump_type || steps.current_predict.outputs.bump_type }}
  major_bump_detected:
    description: "True if major bump was detected and protection was applied"
    value: ${{ github.event_name == 'pull_request' && (steps.forward_predict.outputs.bump_type == 'major' || steps.current_predict.outputs.bump_type == 'major') && inputs['enforce-major-approval'] == 'true' }}

runs:
  using: "composite"
  steps:
    - name: Ensure full git history (best-effort)
      shell: bash
      run: |
        set -euo pipefail
        # Attempt to unshallow so describe/commit scan works; ignore if already full.
        git fetch --prune --tags --unshallow 2>/dev/null || true
        # Fallback shallow fetch of tags if unshallow not possible
        git fetch --prune --tags --depth=200 2>/dev/null || true
        # Make sure we have the latest default branch ref (important for PR context)
        git fetch origin "${{ inputs['target-branch'] }}" --depth=200 2>/dev/null || true

    - name: Validate PR Title (Prevent Release Issues)
      if: ${{ github.event_name == 'pull_request' }}
      shell: bash
      run: |
        set -euo pipefail
        PR_TITLE="${{ github.event.pull_request.title }}"
        HEAD_BRANCH="${{ github.event.pull_request.head.ref }}"
        echo "ðŸ” Checking PR title: $PR_TITLE"
        echo "ðŸ” Source branch: $HEAD_BRANCH"

        # Check if PR title follows conventional commit format (strict) or GitHub auto-generated format (flexible)
        if ! echo "$PR_TITLE" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)(\(.+\))?[:/] .+' && \
           ! echo "$PR_TITLE" | grep -qE '^(Feat|Fix|Docs|Style|Refactor|Perf|Test|Build|Ci|Chore|Revert)[/].+' && \
           ! echo "$PR_TITLE" | grep -qE '^(feat|fix|docs|style|refactor|perf|test|build|ci|chore|revert)[/-].+'; then
          echo "âŒ ERROR: PR title must follow conventional commit format!"
          echo ""
          echo "Examples:"
          echo "  âœ… feat: add new functionality"
          echo "  âœ… fix: resolve login issue" 
          echo "  âœ… chore: update dependencies"
          echo "  âœ… Feat/user export (GitHub auto-generated - capitalized)"
          echo "  âœ… feat/pre-release (GitHub auto-generated - lowercase)"
          echo "  âœ… feat-pre-release (GitHub auto-generated - with hyphen)"
          echo ""
          echo "Current title: '$PR_TITLE'"
          echo ""
          echo "ðŸ’¡ TIP: Use conventional branch names to get better auto-generated PR titles:"
          echo "  Branch 'feat/user-export' â†’ PR title 'Feat/user export'"
          echo "  Branch 'fix/login-bug' â†’ PR title 'Fix/login bug'"
          echo ""
          echo "âš ï¸  This title becomes the merge commit message and must be conventional for releases to work!"
          echo "ðŸ”§ Fix: Edit your PR title to use format 'type: description'"
          exit 1
        fi
        echo "âœ… PR title follows conventional commit format"

    - name: Get current tag baseline
      id: baseline
      shell: bash
      run: |
        set -euo pipefail
        DEFAULT_BRANCH='${{ inputs['target-branch'] }}'
        git fetch origin "$DEFAULT_BRANCH" --tags --force >/dev/null 2>&1 || true
        # Find highest semver tag on default branch
        CANDIDATES=$(git tag --merged "origin/$DEFAULT_BRANCH" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)
        if [ -n "$CANDIDATES" ]; then
          CURRENT_TAG=$(echo "$CANDIDATES" | awk -F'[v.]' '{printf "%s %d %d %d\n",$0,$2,$3,$4}' | sort -k2,2n -k3,3n -k4,4n | tail -n1 | cut -d' ' -f1)
        else
          CURRENT_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo 'v0.0.0')
        fi
        echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
        echo "Current tag: $CURRENT_TAG" | tee -a baseline.log

    - name: Predict next tag after merge using release-please action
      id: forward_predict_action
      if: github.event_name == 'pull_request'
      uses: googleapis/release-please-action@v4
      with:
        release-type: ${{ inputs.release-type }}
        config-file: ${{ inputs.config-file }}
        manifest-file: ${{ inputs.manifest-file }}
        include-component-in-tag: false
        token: ${{ github.token }}

    - name: Process release-please outputs for PR prediction
      id: forward_predict
      if: github.event_name == 'pull_request'
      shell: bash
      run: |
        set -euo pipefail

        # Get outputs from release-please action
        RELEASE_CREATED="${{ steps.forward_predict_action.outputs.release_created }}"
        TAG_NAME="${{ steps.forward_predict_action.outputs.tag_name }}"
        PR_CREATED="${{ steps.forward_predict_action.outputs.pr_created }}"
        PR_NUMBER="${{ steps.forward_predict_action.outputs.pr_number }}"

        echo "Release-please action outputs:" | tee -a baseline.log
        echo "  release_created: $RELEASE_CREATED" | tee -a baseline.log
        echo "  tag_name: $TAG_NAME" | tee -a baseline.log
        echo "  pr_created: $PR_CREATED" | tee -a baseline.log
        echo "  pr_number: $PR_NUMBER" | tee -a baseline.log

        # Determine what would happen if merged
        CURRENT_TAG='${{ steps.baseline.outputs.current_tag }}'

        if [ -n "$TAG_NAME" ] && [ "$TAG_NAME" != "null" ] && [ "$TAG_NAME" != "" ]; then
          # Release-please would create a release with this tag
          NEXT_TAG="$TAG_NAME"
          echo "Release-please would create tag: $NEXT_TAG" | tee -a baseline.log
        elif [ "$PR_CREATED" = "true" ] || [ -n "$PR_NUMBER" ]; then
          # A release PR would be created, estimate the version from manifest + commits
          # Read current manifest version
          MANIFEST_VERSION=$(cat '${{ inputs.manifest-file }}' | grep -o '"[0-9.]*"' | head -1 | tr -d '"' || echo "")
          if [ -n "$MANIFEST_VERSION" ]; then
            # Check commits for bump type
            COMMITS=$(git log $CURRENT_TAG..HEAD --pretty=format:'%s' 2>/dev/null || echo "")
            if echo "$COMMITS" | grep -qE '^feat(\(|:)'; then
              # Has feat commits, would be minor bump
              IFS=. read -r MAJ MIN PAT <<< "$MANIFEST_VERSION"
              MIN=$((MIN+1))
              PAT=0
              NEXT_TAG="v$MAJ.$MIN.$PAT"
            elif echo "$COMMITS" | grep -qE '^fix(\(|:)'; then
              # Has fix commits, would be patch bump
              IFS=. read -r MAJ MIN PAT <<< "$MANIFEST_VERSION"
              PAT=$((PAT+1))
              NEXT_TAG="v$MAJ.$MIN.$PAT"
            else
              NEXT_TAG="$CURRENT_TAG"
            fi
          else
            NEXT_TAG="$CURRENT_TAG"
          fi
          echo "Estimated next tag from manifest and commits: $NEXT_TAG" | tee -a baseline.log
        else
          # No release would be created
          NEXT_TAG="$CURRENT_TAG"
          echo "No release would be created, staying at: $NEXT_TAG" | tee -a baseline.log
        fi

        # Determine bump type
        CURRENT_VER=${CURRENT_TAG#v}
        NEXT_VER=${NEXT_TAG#v}

        if [ "$CURRENT_VER" = "$NEXT_VER" ]; then
          BUMP=none
        else
          # Parse version numbers
          IFS=. read -r C_MAJ C_MIN C_PAT <<< "${CURRENT_VER%%-*}"
          IFS=. read -r N_MAJ N_MIN N_PAT <<< "${NEXT_VER%%-*}"
          
          if [ "$N_MAJ" -gt "$C_MAJ" ]; then
            BUMP=major
          elif [ "$N_MIN" -gt "$C_MIN" ]; then
            BUMP=minor
          elif [ "$N_PAT" -gt "$C_PAT" ]; then
            BUMP=patch
          else
            BUMP=none
          fi
        fi

        echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
        echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
        echo "Next tag after merge: $NEXT_TAG (bump: $BUMP)" | tee -a baseline.log
        echo "Using release-please action ensures consistency with actual release workflow" | tee -a baseline.log

    - name: Predict next tag for current state (non-PR events)
      id: current_predict
      if: github.event_name != 'pull_request'
      shell: bash
      run: |
        set -euo pipefail
        TARGET='${{ inputs['target-branch'] }}'

        # Use release-please CLI to see what the current state would release
        echo "Running release-please in dry-run mode for current state..." | tee -a baseline.log

        # Set up git config (required for release-please)
        git config user.name github-actions[bot] || true
        git config user.email 41898282+github-actions[bot]@users.noreply.github.com || true

        # Run release-please in dry-run mode
        RELEASE_OUTPUT=$(release-please release-pr \
          --release-type='${{ inputs.release-type }}' \
          --target-branch="$TARGET" \
          --config-file='${{ inputs.config-file }}' \
          --manifest-file='${{ inputs.manifest-file }}' \
          --dry-run 2>&1 || true)

        echo "Release-please output for current state:" | tee -a baseline.log
        echo "$RELEASE_OUTPUT" | tee -a baseline.log

        # Parse the output to extract version information
        NEXT_TAG=$(echo "$RELEASE_OUTPUT" | grep -oE 'v[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?' | head -1 || echo "")

        if [ -z "$NEXT_TAG" ]; then
          # Fallback: try to extract from "release" or "version" mentions
          NEXT_VER=$(echo "$RELEASE_OUTPUT" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.-]+)?' | head -1 || echo "")
          if [ -n "$NEXT_VER" ]; then
            NEXT_TAG="v$NEXT_VER"
          else
            # No version change detected, use current tag
            NEXT_TAG='${{ steps.baseline.outputs.current_tag }}'
            echo "No version change detected, staying at $NEXT_TAG" | tee -a baseline.log
          fi
        fi

        # Determine bump type by comparing with current tag
        CURRENT_TAG='${{ steps.baseline.outputs.current_tag }}'
        CURRENT_VER=${CURRENT_TAG#v}
        NEXT_VER=${NEXT_TAG#v}

        if [ "$CURRENT_VER" = "$NEXT_VER" ]; then
          BUMP=none
        else
          # Parse version numbers
          IFS=. read -r C_MAJ C_MIN C_PAT <<< "${CURRENT_VER%%-*}"
          IFS=. read -r N_MAJ N_MIN N_PAT <<< "${NEXT_VER%%-*}"
          
          if [ "$N_MAJ" -gt "$C_MAJ" ]; then
            BUMP=major
          elif [ "$N_MIN" -gt "$C_MIN" ]; then
            BUMP=minor
          elif [ "$N_PAT" -gt "$C_PAT" ]; then
            BUMP=patch
          else
            BUMP=none
          fi
        fi

        echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
        echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
        echo "Current state would create: $NEXT_TAG (bump: $BUMP)" | tee -a baseline.log
        echo "Using release-please CLI ensures consistency with actual release workflow" | tee -a baseline.log

    - name: Check for Version Conflicts
      if: github.event_name == 'pull_request'
      id: conflict_check
      shell: bash
      run: |
        set -euo pipefail
        NEXT_TAG='${{ steps.forward_predict.outputs.next_tag }}'
        TARGET_BRANCH='${{ inputs['target-branch'] }}'

        # Check if the next tag already exists
        if git tag | grep -q "^${NEXT_TAG}$"; then
          echo "version_conflict=true" >> $GITHUB_OUTPUT
          echo "conflict_message=âš ï¸ Version conflict detected: Tag $NEXT_TAG already exists!" >> $GITHUB_OUTPUT
          echo "VERSION CONFLICT: $NEXT_TAG already exists" | tee -a baseline.log
        else
          echo "version_conflict=false" >> $GITHUB_OUTPUT
          echo "conflict_message=" >> $GITHUB_OUTPUT
          echo "No version conflicts detected" | tee -a baseline.log
        fi

    - name: Compute artifact name
      id: artifact_name
      shell: bash
      run: |
        set -euo pipefail
        BASE="${{ inputs['artifact-name'] }}"
        if [ "${{ inputs['unique-suffix'] }}" = "true" ]; then
          P="${{ inputs.path }}"
          [ "$P" = "." ] && P="root"
          SAFE=$(echo "$P" | tr '/ ' '__')
          VALUE="${BASE}-${SAFE}-${{ github.job }}-${{ github.run_attempt }}"
        else
          VALUE="$BASE"
        fi
        echo "Computed artifact name: $VALUE"
        echo "value=$VALUE" >> $GITHUB_OUTPUT

    - name: Upload log
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.artifact_name.outputs.value }}
        path: baseline.log
        if-no-files-found: warn

    - name: Major Bump Protection
      if: ${{ github.event_name == 'pull_request' && steps.forward_predict.outputs.bump_type == 'major' && inputs['enforce-major-approval'] == 'true' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const {owner, repo} = context.repo;
          const issue_number = context.issue.number;

          // Add major-release and requires-approval labels
          try {
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number,
              labels: ['major-release', 'requires-approval']
            });
            core.info('Added major-release and requires-approval labels');
          } catch (error) {
            core.warning(`Failed to add labels: ${error.message}`);
          }

          // Post warning comment about major bump
          const warningMarker = '<!-- major-bump-warning -->';
          const currentTag = `${{ steps.baseline.outputs.current_tag }}`;
          const nextTag = `${{ steps.forward_predict.outputs.next_tag }}`;

          const warningBody = warningMarker + `
          ## âš ï¸ Major Version Bump Detected!

          This PR contains **breaking changes** that will create a major release:

          - **Current Version**: \`${currentTag}\`
          - **Next Version**: \`${nextTag}\`
          - **Impact**: This is a **BREAKING CHANGE** that may affect consumers

          ### Required Actions:
          1. ðŸ·ï¸ **Labels Added**: \`major-release\`, \`requires-approval\`
          2. ðŸ‘¥ **Review Required**: A senior maintainer must approve this PR
          3. ðŸ“‹ **Breaking Changes**: Document all breaking changes in the PR description
          4. ðŸ“¢ **Communication**: Plan release announcement and migration guide

          ### Before Merging:
          - [ ] Breaking changes documented
          - [ ] Migration guide provided
          - [ ] Team/consumers notified
          - [ ] Senior maintainer approval obtained

          **Do not merge until all requirements are met!**`;

          // Check if warning comment already exists
          const comments = await github.paginate(github.rest.issues.listComments, {owner, repo, issue_number});
          const existingWarning = comments.find(c => c.body && c.body.includes(warningMarker));

          if (existingWarning) {
            await github.rest.issues.updateComment({
              owner,
              repo,
              comment_id: existingWarning.id,
              body: warningBody
            });
            core.info('Updated existing major bump warning comment');
          } else {
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number,
              body: warningBody
            });
            core.info('Created new major bump warning comment');
          }

          // Request reviews from repository maintainers (if CODEOWNERS exists)
          try {
            const codeowners = await github.rest.repos.getContent({
              owner,
              repo,
              path: '.github/CODEOWNERS'
            });
            core.info('CODEOWNERS file found - review requests should be automatic');
          } catch (error) {
            core.warning('No CODEOWNERS file found. Consider adding one for automatic review requests on major bumps.');
          }

    - name: PR Comment (Simple Version)
      if: ${{ github.event_name == 'pull_request' && inputs['pr-comment'] == 'true' }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ github.token }}
        script: |
          const marker = '<!-- ' + `${{ inputs['pr-comment-marker'] }}` + ' -->';
          const currentTag = `${{ steps.baseline.outputs.current_tag }}` || 'none';
          const nextTag = `${{ steps.forward_predict.outputs.next_tag }}` || 'none';
          const bumpType = `${{ steps.forward_predict.outputs.bump_type }}` || 'none';
          const hasVersionConflict = `${{ steps.conflict_check.outputs.version_conflict }}` === 'true';
          const conflictMessage = `${{ steps.conflict_check.outputs.conflict_message }}`;

          // Add warning icon for major bumps or version conflicts
          const bumpTypeDisplay = bumpType === 'major' ? 'âš ï¸ `major` (BREAKING)' : `\`${bumpType}\``;
          const headerEmoji = bumpType === 'major' || hasVersionConflict ? 'âš ï¸ ' : '';

          // Build version conflict warning
          const versionConflictWarning = hasVersionConflict ? `

          > **ðŸš¨ VERSION CONFLICT DETECTED!**
          > 
          > ${conflictMessage}
          > 
          > **Resolution needed:**
          > 1. Rebase your branch: \`git rebase v${ nextTag.replace('v', '').split('.').slice(0, 2).join('.') }.0\`
          > 2. Update any RC tags if needed
          > 3. The version will automatically increment to the next available number
          ` : '';

          const body = marker + `
          ### ${headerEmoji}Release Dry Run Result

          | Field | Value |
          |-------|-------|
          | Current Tag | \`${currentTag}\` |
          | Next Tag After Merge | \`${nextTag}\` |
          | Bump Type | ${bumpTypeDisplay} |

          ${bumpType === 'major' ? '> **Warning**: This PR contains breaking changes! Check labels and approval requirements.' : ''}${versionConflictWarning}

          _Comment updates automatically on each run._`;

          const {owner, repo} = context.repo;
          const issue_number = context.issue.number;
          // Fetch existing comments and look for marker
          const comments = await github.paginate(github.rest.issues.listComments, {owner, repo, issue_number});
          const existing = comments.find(c => c.body && c.body.includes(marker));
          if (existing) {
            await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            core.info('Updated existing dry-run comment.');
          } else {
            await github.rest.issues.createComment({owner, repo, issue_number, body});
            core.info('Created new dry-run comment.');
          }

    - name: Step Summary
      if: always()
      shell: bash
      run: |
        {
          echo '### Release Dry Run';
          echo '';
          echo '* Current tag: `${{ steps.baseline.outputs.current_tag }}`';
          echo '* Next tag: `${{ steps.forward_predict.outputs.next_tag }}`';
          echo '* Bump type: `${{ steps.forward_predict.outputs.bump_type }}`';
        } >> $GITHUB_STEP_SUMMARY
