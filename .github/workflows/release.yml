name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    runs-on: self-hosted
    steps:
      - name: Checkout (full history for tagging)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Reconcile release state
        run: |
          echo "üîç Checking for state inconsistencies..."
          
          # Fetch all tags and check for orphaned releases
          git fetch --tags --force
          
          # Find releases without corresponding tags
          echo "Checking for releases without tags..."
          for release_tag in $(gh api repos/:owner/:repo/releases --jq '.[].tag_name' | head -10); do
            if ! git tag -l | grep -q "^${release_tag}$"; then
              echo "‚ö†Ô∏è  Found release $release_tag without local tag"
              # Get the commit SHA for this release
              commit_sha=$(gh release view $release_tag --json targetCommitish --jq '.targetCommitish')
              if [ -n "$commit_sha" ]; then
                echo "Creating missing tag $release_tag at $commit_sha"
                git tag $release_tag $commit_sha || true
                git push origin $release_tag || echo "Tag $release_tag already exists remotely"
              fi
            fi
          done
          
          # Find tags without corresponding releases and clean them up
          echo "Checking for orphaned tags without releases..."
          for tag in $(git tag -l | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -10); do
            if ! gh release view $tag >/dev/null 2>&1; then
              echo "üßπ Found orphaned tag $tag without GitHub release - cleaning up"
              
              # Delete the orphaned tag locally and remotely
              git tag -d $tag || true
              git push origin ":$tag" || true
              
              echo "‚úÖ Cleaned up orphaned tag: $tag"
            fi
          done
          
          echo "‚úÖ State reconciliation complete"

      - name: Release Please
        id: release
        uses: googleapis/release-please-action@v4
        with:
          release-type: simple
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate release creation
        if: steps.release.outputs.release_created == 'true'
        run: |
          echo "‚úÖ Release created: ${{ steps.release.outputs.tag_name }}"
          
          # Verify both tag and release exist
          tag_name="${{ steps.release.outputs.tag_name }}"
          
          if ! git tag -l | grep -q "^${tag_name}$"; then
            echo "‚ùå Tag $tag_name not found locally"
            exit 1
          fi
          
          if ! gh release view "$tag_name" >/dev/null 2>&1; then
            echo "‚ùå GitHub release $tag_name not found"
            exit 1
          fi
          
          echo "‚úÖ Both tag and release verified successfully"

      - name: Show outputs
        run: |
          echo "release_created=${{ steps.release.outputs.release_created }}"
          echo "tag=${{ steps.release.outputs.tag_name }}"
          echo "version=${{ steps.release.outputs.major }}.${{ steps.release.outputs.minor }}.${{ steps.release.outputs.patch }}"

      - name: Create floating tags (safer approach)
        if: ${{ steps.release.outputs.release_created == 'true' }}
        run: |
          echo "üè∑Ô∏è  Creating floating tags for ${{ steps.release.outputs.tag_name }}"
          
          # Verify the release actually exists before creating floating tags
          if ! gh release view "${{ steps.release.outputs.tag_name }}" >/dev/null 2>&1; then
            echo "‚ùå Release ${{ steps.release.outputs.tag_name }} not found! Skipping floating tags."
            exit 1
          fi
          
          git config user.name github-actions[bot]
          git config user.email 41898282+github-actions[bot]@users.noreply.github.com
          
          MAJOR="${{ steps.release.outputs.major }}"
          MINOR="${{ steps.release.outputs.minor }}"
          FULL_TAG="${{ steps.release.outputs.tag_name }}"
          
          # Create floating tags with better error handling
          for floating_tag in "v${MAJOR}" "v${MAJOR}.${MINOR}"; do
            echo "Processing floating tag: $floating_tag -> $FULL_TAG"
            
            # Delete remote tag if exists (safer than force push)
            if git ls-remote --tags origin | grep -q "refs/tags/$floating_tag$"; then
              echo "Deleting existing remote tag: $floating_tag"
              git push origin ":$floating_tag" || echo "Failed to delete $floating_tag, continuing..."
            fi
            
            # Create/update local tag
            git tag -fa "$floating_tag" -m "Floating tag $floating_tag -> $FULL_TAG"
            
            # Push new tag
            if git push origin "$floating_tag"; then
              echo "‚úÖ Successfully created floating tag: $floating_tag"
            else
              echo "‚ùå Failed to create floating tag: $floating_tag"
              # Don't fail the entire workflow for floating tag issues
            fi
          done

      - name: Upload artifact (if present)
        if: ${{ steps.release.outputs.release_created == 'true' }}
        run: |
          if [ -f artifact/some-build-artifact.zip ]; then
            gh release upload ${{ steps.release.outputs.tag_name }} artifact/some-build-artifact.zip
          else
            echo "No artifact found; skipping upload"
          fi
