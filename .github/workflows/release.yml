name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    runs-on: self-hosted
    steps:
      - name: Checkout (full history for tagging)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate Next Version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          
          # Find highest semver tag on main branch (same logic as dry-run)
          CANDIDATES=$(git tag --merged main | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)
          if [ -n "$CANDIDATES" ]; then
            CURRENT_TAG=$(echo "$CANDIDATES" | awk -F'[v.]' '{printf "%s %d %d %d\n",$0,$2,$3,$4}' | sort -k2,2n -k3,3n -k4,4n | tail -n1 | cut -d' ' -f1)
          else
            CURRENT_TAG="v0.0.0"
          fi

          echo "Current tag: $CURRENT_TAG"

          # Analyze commits since last tag for bump type
          COMMITS_SINCE_TAG=$(git log $CURRENT_TAG..HEAD --pretty=format:'%s' 2>/dev/null || echo "")
          echo "Commits since $CURRENT_TAG:"
          echo "$COMMITS_SINCE_TAG"

          # Determine bump type (same logic as dry-run)
          if echo "$COMMITS_SINCE_TAG" | grep -qE '^[^:]*!:|BREAKING CHANGE'; then
            BUMP=major
            echo "Found breaking changes - major bump"
          elif echo "$COMMITS_SINCE_TAG" | grep -qE '^feat(\(|:)'; then
            BUMP=minor
            echo "Found feat commits - minor bump"
          elif echo "$COMMITS_SINCE_TAG" | grep -qE '^(fix|perf)(\(|:)'; then
            BUMP=patch
            echo "Found fix/perf commits - patch bump"
          else
            BUMP=none
            echo "No significant commits found - no release needed"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Calculate next version
          CURRENT_VER=${CURRENT_TAG#v}
          IFS=. read -r MAJ MIN PAT <<< "$CURRENT_VER"

          case $BUMP in
            major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
            minor) MIN=$((MIN+1)); PAT=0 ;;
            patch) PAT=$((PAT+1)) ;;
          esac

          NEXT_VER="$MAJ.$MIN.$PAT"
          NEXT_TAG="v$NEXT_VER"

          echo "Next version: $NEXT_VER"
          echo "Next tag: $NEXT_TAG"
          echo "Bump type: $BUMP"

          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
          echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
          echo "next_version=$NEXT_VER" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
          echo "skip_release=false" >> $GITHUB_OUTPUT

      - name: Generate Changelog
        if: steps.version.outputs.skip_release != 'true'
        id: changelog
        shell: bash
        run: |
          set -euo pipefail
          
          CURRENT_TAG="${{ steps.version.outputs.current_tag }}"
          NEXT_TAG="${{ steps.version.outputs.next_tag }}"
          
          # Generate changelog from commits
          echo "## Changes since $CURRENT_TAG" > changelog.md
          echo "" >> changelog.md
          
          # Features
          FEATURES=$(git log $CURRENT_TAG..HEAD --pretty=format:'%s (%h)' | grep -E '^feat(\(|:)' || true)
          if [ -n "$FEATURES" ]; then
            echo "### Features" >> changelog.md
            echo "$FEATURES" | sed 's/^/* /' >> changelog.md
            echo "" >> changelog.md
          fi
          
          # Bug Fixes
          FIXES=$(git log $CURRENT_TAG..HEAD --pretty=format:'%s (%h)' | grep -E '^fix(\(|:)' || true)
          if [ -n "$FIXES" ]; then
            echo "### Bug Fixes" >> changelog.md
            echo "$FIXES" | sed 's/^/* /' >> changelog.md
            echo "" >> changelog.md
          fi
          
          # Other Changes
          OTHERS=$(git log $CURRENT_TAG..HEAD --pretty=format:'%s (%h)' | grep -E '^(perf|refactor|docs|style|test|build|ci|chore)(\(|:)' || true)
          if [ -n "$OTHERS" ]; then
            echo "### Other Changes" >> changelog.md
            echo "$OTHERS" | sed 's/^/* /' >> changelog.md
            echo "" >> changelog.md
          fi
          
          # Set output using proper delimiter
          {
            echo 'release_body<<CHANGELOG_EOF'
            cat changelog.md
            echo 'CHANGELOG_EOF'
          } >> $GITHUB_OUTPUT

      - name: Create Release PR
        if: steps.version.outputs.skip_release != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const nextVersion = '${{ steps.version.outputs.next_version }}';
            const nextTag = '${{ steps.version.outputs.next_tag }}';
            const bumpType = '${{ steps.version.outputs.bump_type }}';
            const releaseBody = `${{ steps.changelog.outputs.release_body }}`.replace(/\r/g, '');
            
            console.log(`Creating release for ${nextTag}`);
            console.log(`Version: ${nextVersion}, Bump: ${bumpType}`);
            
            // Check if release PR already exists
            let existingPRs;
            try {
              const response = await github.rest.pulls.list({
                owner,
                repo,
                head: `${owner}:release-please--branches--main`,
                base: 'main',
                state: 'open'
              });
              existingPRs = response.data;
            } catch (error) {
              console.log('Error checking for existing PRs:', error.message);
              existingPRs = [];
            }
            
            const prTitle = `chore(main): release ${nextVersion}`;
            const prBody = [
              `## Release ${nextTag}`,
              '',
              'This PR was generated by the custom release workflow.',
              '',
              releaseBody,
              '',
              '### Release Information',
              `- **Version**: ${nextVersion}`,
              `- **Bump type**: ${bumpType}`,
              `- **Tag**: ${nextTag}`,
              '',
              '---',
              `*This PR will create the ${nextTag} release when merged.*`
            ].join('\n');
            
            if (existingPRs.length > 0) {
              // Update existing PR
              try {
                await github.rest.pulls.update({
                  owner,
                  repo,
                  pull_number: existingPRs[0].number,
                  title: prTitle,
                  body: prBody
                });
                console.log(`Updated existing release PR #${existingPRs[0].number}`);
              } catch (error) {
                console.log('Error updating PR:', error.message);
                throw error;
              }
            } else {
              console.log('Creating new release branch and PR...');
              
              // Get main branch reference
              const mainRef = await github.rest.git.getRef({
                owner,
                repo,
                ref: 'heads/main'
              });
              
              // Create or update release branch
              const branchName = 'release-please--branches--main';
              try {
                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: `refs/heads/${branchName}`,
                  sha: mainRef.data.object.sha
                });
                console.log('Created new release branch');
              } catch (error) {
                if (error.status === 422) {
                  // Branch already exists, update it
                  await github.rest.git.updateRef({
                    owner,
                    repo,
                    ref: `heads/${branchName}`,
                    sha: mainRef.data.object.sha
                  });
                  console.log('Updated existing release branch');
                } else {
                  throw error;
                }
              }
              
              // Update manifest file in the release branch
              const manifestContent = JSON.stringify({ ".": nextVersion }, null, 2);
              
              try {
                // Try to get existing manifest file
                const currentFile = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: '.release-please-manifest.json',
                  ref: branchName
                });
                
                // Update existing file
                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: '.release-please-manifest.json',
                  message: `chore: update manifest to ${nextVersion}`,
                  content: Buffer.from(manifestContent).toString('base64'),
                  sha: currentFile.data.sha,
                  branch: branchName
                });
                console.log('Updated manifest file');
              } catch (error) {
                if (error.status === 404) {
                  // File doesn't exist, create it
                  await github.rest.repos.createOrUpdateFileContents({
                    owner,
                    repo,
                    path: '.release-please-manifest.json',
                    message: `chore: create manifest with ${nextVersion}`,
                    content: Buffer.from(manifestContent).toString('base64'),
                    branch: branchName
                  });
                  console.log('Created manifest file');
                } else {
                  throw error;
                }
              }
              
              // Create the PR
              const pr = await github.rest.pulls.create({
                owner,
                repo,
                title: prTitle,
                head: branchName,
                base: 'main',
                body: prBody
              });
              
              console.log(`Created new release PR #${pr.data.number}`);
            }

      - name: Check if Release PR was Merged
        if: steps.version.outputs.skip_release != 'true'
        uses: actions/github-script@v7
        id: check_merge
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            
            // Check if this push was a merge of the release PR
            const { data: commit } = await github.rest.repos.getCommit({
              owner,
              repo,
              ref: context.sha
            });
            
            const isReleasePRMerge = commit.commit.message.includes('chore(main): release');
            console.log(`Is release PR merge: ${isReleasePRMerge}`);
            console.log(`Commit message: ${commit.commit.message}`);
            
            return { merged: isReleasePRMerge };

      - name: Create Tag and GitHub Release
        if: steps.version.outputs.skip_release != 'true' && fromJSON(steps.check_merge.outputs.result).merged
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const nextTag = '${{ steps.version.outputs.next_tag }}';
            const nextVersion = '${{ steps.version.outputs.next_version }}';
            const releaseBody = `${{ steps.changelog.outputs.release_body }}`;
            
            // Create the tag
            await github.rest.git.createTag({
              owner,
              repo,
              tag: nextTag,
              message: `Release ${nextTag}`,
              object: context.sha,
              type: 'commit'
            });
            
            // Create the tag reference
            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${nextTag}`,
              sha: context.sha
            });
            
            // Create the GitHub release
            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: nextTag,
              name: nextTag,
              body: releaseBody,
              draft: false,
              prerelease: false
            });
            
            console.log(`Created release ${nextTag}`);

      - name: Tag major and minor floating refs
        if: steps.version.outputs.skip_release != 'true' && fromJSON(steps.check_merge.outputs.result).merged
        shell: bash
        run: |
          NEXT_TAG="${{ steps.version.outputs.next_tag }}"
          NEXT_VER="${{ steps.version.outputs.next_version }}"
          
          # Extract major and minor versions
          IFS=. read -r MAJ MIN PAT <<< "$NEXT_VER"
          
          git config user.name github-actions[bot]
          git config user.email 41898282+github-actions[bot]@users.noreply.github.com
          
          for t in v$MAJ v$MAJ.$MIN; do
            git push origin :$t || true
            git tag -fa $t -m "Floating tag $t -> $NEXT_TAG"
            git push origin $t --force
          done

      - name: Summary
        if: always()
        shell: bash
        run: |
          echo "### Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Current tag: ${{ steps.version.outputs.current_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Next tag: ${{ steps.version.outputs.next_tag }}" >> $GITHUB_STEP_SUMMARY  
          echo "- Bump type: ${{ steps.version.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- Skip release: ${{ steps.version.outputs.skip_release }}" >> $GITHUB_STEP_SUMMARY