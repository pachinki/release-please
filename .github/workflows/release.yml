name: Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: release-main
  cancel-in-progress: false

jobs:
  release:
    runs-on: self-hosted
    steps:
      - name: Checkout (full history for tagging)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Calculate Next Version
        id: version
        shell: bash
        run: |
          set -euo pipefail
          
          # Find highest semver tag on main branch (same logic as dry-run)
          CANDIDATES=$(git tag --merged main | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)
          if [ -n "$CANDIDATES" ]; then
            CURRENT_TAG=$(echo "$CANDIDATES" | awk -F'[v.]' '{printf "%s %d %d %d\n",$0,$2,$3,$4}' | sort -k2,2n -k3,3n -k4,4n | tail -n1 | cut -d' ' -f1)
          else
            CURRENT_TAG="v0.0.0"
          fi

          echo "Current tag: $CURRENT_TAG"

          # Analyze commits since last tag for bump type
          COMMITS_SINCE_TAG=$(git log $CURRENT_TAG..HEAD --pretty=format:'%s' 2>/dev/null || echo "")
          echo "Commits since $CURRENT_TAG:"
          echo "$COMMITS_SINCE_TAG"

          # Determine bump type (same logic as dry-run)
          if echo "$COMMITS_SINCE_TAG" | grep -qE '^[^:]*!:|BREAKING CHANGE'; then
            BUMP=major
            echo "Found breaking changes - major bump"
          elif echo "$COMMITS_SINCE_TAG" | grep -qE '^feat(\(|:)'; then
            BUMP=minor
            echo "Found feat commits - minor bump"
          elif echo "$COMMITS_SINCE_TAG" | grep -qE '^(fix|perf)(\(|:)'; then
            BUMP=patch
            echo "Found fix/perf commits - patch bump"
          else
            BUMP=none
            echo "No significant commits found - no release needed"
            echo "skip_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Calculate next version
          CURRENT_VER=${CURRENT_TAG#v}
          IFS=. read -r MAJ MIN PAT <<< "$CURRENT_VER"

          case $BUMP in
            major) MAJ=$((MAJ+1)); MIN=0; PAT=0 ;;
            minor) MIN=$((MIN+1)); PAT=0 ;;
            patch) PAT=$((PAT+1)) ;;
          esac

          NEXT_VER="$MAJ.$MIN.$PAT"
          NEXT_TAG="v$NEXT_VER"

          echo "Next version: $NEXT_VER"
          echo "Next tag: $NEXT_TAG"
          echo "Bump type: $BUMP"

          echo "current_tag=$CURRENT_TAG" >> $GITHUB_OUTPUT
          echo "next_tag=$NEXT_TAG" >> $GITHUB_OUTPUT
          echo "next_version=$NEXT_VER" >> $GITHUB_OUTPUT
          echo "bump_type=$BUMP" >> $GITHUB_OUTPUT
          echo "skip_release=false" >> $GITHUB_OUTPUT

      - name: Generate Changelog
        if: steps.version.outputs.skip_release != 'true'
        id: changelog
        shell: bash
        run: |
          set -euo pipefail
          
          CURRENT_TAG="${{ steps.version.outputs.current_tag }}"
          NEXT_TAG="${{ steps.version.outputs.next_tag }}"
          
          # Generate changelog from commits
          echo "# Changelog" > changelog.md
          echo "" >> changelog.md
          
          # Get commits since last tag and categorize them
          git log $CURRENT_TAG..HEAD --pretty=format:'%s (%h)' | while read line; do
            if echo "$line" | grep -qE '^feat(\(|:)'; then
              echo "### Features" >> changelog.md
              echo "* $line" >> changelog.md
            elif echo "$line" | grep -qE '^fix(\(|:)'; then
              echo "### Bug Fixes" >> changelog.md  
              echo "* $line" >> changelog.md
            elif echo "$line" | grep -qE '^(perf|refactor|docs|style|test|build|ci|chore)(\(|:)'; then
              echo "### Other Changes" >> changelog.md
              echo "* $line" >> changelog.md
            fi
          done
          
          # Create release body
          RELEASE_BODY=$(cat changelog.md)
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release PR
        if: steps.version.outputs.skip_release != 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const nextVersion = '${{ steps.version.outputs.next_version }}';
            const nextTag = '${{ steps.version.outputs.next_tag }}';
            const bumpType = '${{ steps.version.outputs.bump_type }}';
            const releaseBody = `${{ steps.changelog.outputs.release_body }}`;
            
            // Check if release PR already exists
            const { data: pulls } = await github.rest.pulls.list({
              owner,
              repo,
              head: 'release-please--branches--main',
              base: 'main',
              state: 'open'
            });
            
            const prTitle = `chore(main): release ${nextVersion}`;
            const prBody = `## Release ${nextTag}
            
            This PR was generated by the custom release workflow.
            
            ${releaseBody}
            
            ### Release Notes
            - Version: ${nextVersion}
            - Bump type: ${bumpType}
            - Tag: ${nextTag}
            `;
            
            if (pulls.length > 0) {
              // Update existing PR
              await github.rest.pulls.update({
                owner,
                repo,
                pull_number: pulls[0].number,
                title: prTitle,
                body: prBody
              });
              console.log(`Updated existing release PR #${pulls[0].number}`);
            } else {
              // Create new release branch and PR
              const { data: mainRef } = await github.rest.git.getRef({
                owner,
                repo,
                ref: 'heads/main'
              });
              
              try {
                await github.rest.git.createRef({
                  owner,
                  repo,
                  ref: 'refs/heads/release-please--branches--main',
                  sha: mainRef.object.sha
                });
              } catch (error) {
                if (error.status === 422) {
                  // Branch already exists, update it
                  await github.rest.git.updateRef({
                    owner,
                    repo,
                    ref: 'heads/release-please--branches--main',
                    sha: mainRef.object.sha
                  });
                } else {
                  throw error;
                }
              }
              
              // Update manifest file in the release branch
              const manifestContent = JSON.stringify({ ".": nextVersion }, null, 2);
              
              try {
                const { data: currentFile } = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: '.release-please-manifest.json',
                  ref: 'release-please--branches--main'
                });
                
                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: '.release-please-manifest.json',
                  message: `chore: update manifest to ${nextVersion}`,
                  content: Buffer.from(manifestContent).toString('base64'),
                  sha: currentFile.sha,
                  branch: 'release-please--branches--main'
                });
              } catch (error) {
                // File might not exist, create it
                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: '.release-please-manifest.json',
                  message: `chore: create manifest with ${nextVersion}`,
                  content: Buffer.from(manifestContent).toString('base64'),
                  branch: 'release-please--branches--main'
                });
              }
              
              // Create the PR
              const { data: pr } = await github.rest.pulls.create({
                owner,
                repo,
                title: prTitle,
                head: 'release-please--branches--main',
                base: 'main',
                body: prBody
              });
              
              console.log(`Created new release PR #${pr.number}`);
            }

      - name: Check if Release PR was Merged
        if: steps.version.outputs.skip_release != 'true'
        uses: actions/github-script@v7
        id: check_merge
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            
            // Check if this push was a merge of the release PR
            const { data: commit } = await github.rest.repos.getCommit({
              owner,
              repo,
              ref: context.sha
            });
            
            const isReleasePRMerge = commit.commit.message.includes('chore(main): release');
            console.log(`Is release PR merge: ${isReleasePRMerge}`);
            console.log(`Commit message: ${commit.commit.message}`);
            
            return { merged: isReleasePRMerge };

      - name: Create Tag and GitHub Release
        if: steps.version.outputs.skip_release != 'true' && fromJSON(steps.check_merge.outputs.result).merged
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const nextTag = '${{ steps.version.outputs.next_tag }}';
            const nextVersion = '${{ steps.version.outputs.next_version }}';
            const releaseBody = `${{ steps.changelog.outputs.release_body }}`;
            
            // Create the tag
            await github.rest.git.createTag({
              owner,
              repo,
              tag: nextTag,
              message: `Release ${nextTag}`,
              object: context.sha,
              type: 'commit'
            });
            
            // Create the tag reference
            await github.rest.git.createRef({
              owner,
              repo,
              ref: `refs/tags/${nextTag}`,
              sha: context.sha
            });
            
            // Create the GitHub release
            await github.rest.repos.createRelease({
              owner,
              repo,
              tag_name: nextTag,
              name: nextTag,
              body: releaseBody,
              draft: false,
              prerelease: false
            });
            
            console.log(`Created release ${nextTag}`);

      - name: Tag major and minor floating refs
        if: steps.version.outputs.skip_release != 'true' && fromJSON(steps.check_merge.outputs.result).merged
        shell: bash
        run: |
          NEXT_TAG="${{ steps.version.outputs.next_tag }}"
          NEXT_VER="${{ steps.version.outputs.next_version }}"
          
          # Extract major and minor versions
          IFS=. read -r MAJ MIN PAT <<< "$NEXT_VER"
          
          git config user.name github-actions[bot]
          git config user.email 41898282+github-actions[bot]@users.noreply.github.com
          
          for t in v$MAJ v$MAJ.$MIN; do
            git push origin :$t || true
            git tag -fa $t -m "Floating tag $t -> $NEXT_TAG"
            git push origin $t --force
          done

      - name: Summary
        if: always()
        shell: bash
        run: |
          echo "### Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "- Current tag: ${{ steps.version.outputs.current_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- Next tag: ${{ steps.version.outputs.next_tag }}" >> $GITHUB_STEP_SUMMARY  
          echo "- Bump type: ${{ steps.version.outputs.bump_type }}" >> $GITHUB_STEP_SUMMARY
          echo "- Skip release: ${{ steps.version.outputs.skip_release }}" >> $GITHUB_STEP_SUMMARY